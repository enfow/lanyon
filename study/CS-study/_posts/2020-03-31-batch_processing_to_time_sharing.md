---
layout: post
title: from Batch processing to Time sharing
category_num: 0
keyword: '[OS]'
---

# Batch processing 부터 Time sharing 까지

- update date : 2020.03.31
- 본 포스팅은 고려대학교 컴퓨터학과 유혁 교수님의 2020년 1학기 Operating system을 수강하고, 이를 바탕으로 작성했습니다.

## Introduction

컴퓨터가 발전하면서 컴퓨터가 작업을 처리하는 방식 또한 그에 맞춰 발전해왔다. 초창기에는 프로세서의 처리 능력 높지 않아 수행해야 할 작업 외에 컴퓨터 자원 관리 등과 같은 부가적인 작업을 수행하는 데에 어려움이 있었고, 따라서 매우 단순한 방식으로 작업을 수행할 수밖에 없었다. 하지만 기술의 발전으로 점차 컴퓨터의 처리 능력 및 저장 공간이 늘어났고 필요에 따라 다양한 작업 처리 방식이 도입되었다.

아래에 제시되고 있는 작업 처리 방식은 도입된 시간 순서대로 나열한 것이며, 최근 일반적인 PC에서는 가장 마지막 기술인 Time sharing이 사용된다. 하지만 이것이 꼭 우열을 나타내는 것은 아니다. 즉 Batch processing이 가장 비효율적이고, Time sharing이 가장 뛰어난 방식이라고 단정 지을 수 없다. 조건에 따라 먼저 나온 기술들이 뒤에 나온 기술보다 효율적일 수도 있기 때문이다. 따라서 각각의 동작 방식을 알아두는 것이 중요하다.

## 1. Batch processing

Batch processing은 어떤 작업이 주어지면 끝날 때까지 컴퓨터는 해당 작업만 수행하는 방식이다. 이때에는 기본적인 프로세서 Scheduling이 도입되기 이전이었고, 따라서 다음에 어떤 작업을 수행할 것인가를 사람이 직접 지정해주어야 했다. 즉, 어떤 프로그램의 수행이 완료되면 사람이 이를 확인하고 다음으로 수행해야 할 프로그램을 전달해주는 방식으로 동작했다.

초창기 기술인 만큼 비효율적이고 다소 답답해보이기도 한다. 특히 무엇보다도 중간중간에 사람이 관여해야 한다는 점에서 그러하다. 다음에 오는 Autometic job seqeuncing은 *Autometic* 이라는 표현에서도 느낌이 오듯, 작업과 작업 사이에 사람이 관여하는 부분을 없앤 기술이다.

## 2. Autometic job sequencing

Autometic job sequencing에서는 **Scheduling**을 담당하는 내부 프로그램이 존재하여 프로그램 종료 후 사람이 다음 작업을 지정해주어야 하는 번거로움을 없앤 방식이다. 이렇게 되면 복수의 작업 sequence를 지정해두면 작업이 완료되면 다음 작업을 컴퓨터가 멈춤 없이 수행할 수 있기 때문에 작업의 효율(CPU 사용률) 면에서도 보다 뛰어나다고 할 수 있다.

하지만 Autometic job sequencing 방식 또한 입출력 과정에서 발생하는 비효율을 개선하지는 못했다. 즉 상대적으로 작업 처리 속도의 면에서 프로세서에 비해 입출력 장치가 느렸기 때문에, 작업의 종료와 시작 과정에서 프로세서가 장시간 유휴상태가 되는 문제가 있었다. Spooling은 이러한 문제를 해결하기 위한 방법으로 도입되었다.

## 3. Spooling

Spooling은 프로세서와 입출력 장치 간의 속도 차이로 인해 발생하는 비효율을 해결하기 위해 **Buffer**를 도입한다. 버퍼란 쉽게 말해 일시적으로 데이터를 저장하는 공간이라고 할 수 있는데, 입력으로 받은 데이터 또는 출력으로 보낼 데이터를 일시적으로 이러한 버퍼에 저장해둘 수 있다. 그렇게 되면 입력 또는 출력이 완료될 때까지 프로세서가 기다릴 필요 없이 버퍼와 데이터를 주고받으며 빠르게 다음 작업으로 넘어갈 수 있다. 참고로 Spooling의 Spool은 *Simultaneous peripheral operation on line*의 약자이다.

## 4. Multi programming

Multi programming의 특징을 한 단어로 표현하라고 한다면 **concurrent** 라고 할 수 있다. 즉 Multi programming 부터는 복수의 작업을 동시에 수행할 수 있게 된 것이다. 이전의 Spooling 까지의 기술들은 메모리 저장 공간의 한계 등으로 인해 메모리 상에 복수의 프로그램을 올리지 못했다. 하지만 Multi programming 은 복수의 프로그램을 메모리 상에 올려두고, 어떤 한 작업이 멈추게 되면 곧바로 다음 프로그램 작업을 수행하는 것이 가능해졌다. 이때 '작업이 멈추게' 되는 가장 대표적인 경우가 입출력을 기다려야만 다음 과정으로 넘어갈 수 있는 경우가 될 것이다. 이를 통해 한 단계 더 CPU 사용률이 높아질 수 있었다.

하지만 Multi programming으로 인한 문제는 실제 사용 과정 상 도덕적 해이로 나타났다. 당시에는 하나의 컴퓨터 시스템(메인 프레임)을 여러 명이 공유해 사용하는 것이 일반적이었는데, 자신의 작업을 빠르게 완료하기 위해서 의도적으로 입출력 과정을 제거해버리는 경우가 있었던 것이다. 또한 Batch processing 부터 계속해서 나타난 문제 중 하나로, 현재 수행 중인 작업에 대해서는 관여할 수 없다는 점이었다. 이 경우 무한 루프에 빠졌을 때 해당 작업을 종료시키는 것이 불가능했다.

## 5. Time sharing

Time sharing은 위의 두 가지 문제에 대한 해결 방안으로 제시되었으며, 현재 대부분의 컴퓨터가 사용하고 있는 기술이다. Time sharing이라는 표현이 의미하듯 복수의 프로그램이 시간을 나누어 동시적으로 처리된다. 쉽게 말해 처음 10ms는 A 작업을 수행했다면 다음 10ms는 B 작업을 수행하고 다시 A 작업으로 돌아가 작업을 시작하는 과정을 반복하는 것이다. 이때 하나의 작업을 수행하는 작업 시간을 **time slice**라고 하고, 작업이 변경되는 것을 **CPU switching**이라고 한다.

이 같은 방법이 Multi programming에서 발생한 도덕적 해이 문제는 해결할 수 있을 것으로 보인다. 입출력 이벤트와 상관 없이 공평하게 여러 프로세스가 절대적인 시간을 부여받고 동시에 처리되기 때문이다. 하지만 두 번째 문제, 즉 다른 작업의 수행에 관여할 수 없다는 문제는 어떻게 해결할 수 있을까. 바로 각각의 CPU switching 사이에 매우 짧은 시간 동안 OS가 CPU를 점유하게 하는 것이다. 이를 통해 각각의 작업을 사용자가 관리할 수 있게 된다.

이것의 가장 쉬운 예가 terminal에서 ctrl-C 를 통해 현재 수행 중인 작업을 강제 종료하는 것이다. OS가 ctrl-C가 입력으로 들어온 것을 확인하고 수행 중인 작업을 종료시킨 것이다. Multi processing은 중간에 OS가 점유하는 시간이 없고 계속 작업이 수행되기 때문에 이것이 불가능하다.

마지막으로 Time sharing은 상대적으로 오버헤드가 많다는 문제를 가지고 있다. 즉 우리의 목표는 처리해야할 작업들을 최대한 빠르게 수행하는 것인데, 빈번한 CPU switching과 중간 중간에 OS가 점유하는 시간 때문에 지연이 발생하게 되고, 이것이 그대로 작업 처리에 있어 오버헤드가 된다. 이러한 문제 때문에 슈퍼컴퓨터 등과 같이 특수한 상황에서는 다른 작업 방식을 택하기도 한다.
